[["index.html", "Random R tricks Section 1 Introduction", " Random R tricks Tran Le 04-01-2022 Updated:2022-07-26 Section 1 Introduction This book-down file is where I keep the observations/tricks I got while using R. I also use this file to write some cheatsheets for later quick reference. "],["problems-when-using-dplyrfull_join.html", "Section 2 Problems when using dplyr::full_join 2.1 Introduction 2.2 Using dplyr::full_join 2.3 Using powerjoin::power_full_join 2.4 What if we have conflict data sets 2.5 Reference", " Section 2 Problems when using dplyr::full_join library(powerjoin) library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✔ ggplot2 3.3.6 ✔ purrr 0.3.4 ## ✔ tibble 3.1.7 ✔ dplyr 1.0.9 ## ✔ tidyr 1.2.0 ✔ stringr 1.4.0 ## ✔ readr 2.1.2 ✔ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 2.1 Introduction This part will explore some problems that we may cope with when using dplyr::full_join, and it is why powerchoice::power_full_join may come in handy. Assume that we have two people: name = John, age = 30, sex = “M”, treatment = NA (we don’t know John’s treatment) name = Marry, age = 45, sex = “F”, treatment = “A” However, we have multiple data sets that contain incomplete information about these two people. Let us consider the data that we have and the problems that we might have to cope with while trying to get data that contains as much information as possible from these two people by joining our available data sets. 2.2 Using dplyr::full_join First, let us consider the below data set. With this data set, we will get the same result while using dfs %&gt;% reduce(full_join) and dfs %&gt;% reduce(full_join, by= name). We do not see any problem here, and we collect all the information from our available data sets. dfs &lt;- list( first = tibble(name = &quot;John&quot;, age = 30), second = tibble(name = c(&quot;John&quot;, &quot;Mary&quot;), sex = c(&quot;M&quot;, &quot;F&quot;)), third = tibble(name = &quot;Mary&quot;, treatment = &quot;A&quot;) ) dfs %&gt;% reduce(full_join) ## Joining, by = &quot;name&quot; ## Joining, by = &quot;name&quot; ## # A tibble: 2 × 4 ## name age sex treatment ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John 30 M &lt;NA&gt; ## 2 Mary NA F A dfs %&gt;% reduce(full_join, by=&quot;name&quot;) ## # A tibble: 2 × 4 ## name age sex treatment ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John 30 M &lt;NA&gt; ## 2 Mary NA F A However, let us consider when our dfs list has one more row (the fourth row) with the name and age of Mary. dfs &lt;- list( first = tibble(name = &quot;John&quot;, age = 30), second = tibble(name = c(&quot;John&quot;, &quot;Mary&quot;), sex = c(&quot;M&quot;, &quot;F&quot;)), third = tibble(name = &quot;Mary&quot;, treatment = &quot;A&quot;), fourth = tibble(name = &quot;Mary&quot;, age = 45) ) The full_join without identifying the key by=\"name\" may think that there are two people with the same name, “Mary”. dfs %&gt;% reduce(full_join) ## Joining, by = &quot;name&quot; ## Joining, by = &quot;name&quot; ## Joining, by = c(&quot;name&quot;, &quot;age&quot;) ## # A tibble: 3 × 4 ## name age sex treatment ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John 30 M &lt;NA&gt; ## 2 Mary NA F A ## 3 Mary 45 &lt;NA&gt; &lt;NA&gt; The full_join with identifying the key by=\"name\"creates extra columns when we have duplicated column names dfs %&gt;% reduce(full_join, by = &quot;name&quot;) ## # A tibble: 2 × 5 ## name age.x sex treatment age.y ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 John 30 M &lt;NA&gt; NA ## 2 Mary NA F A 45 We may think about how to delete these extra columns by doing like below code chunk. However, by doing this, we lost the information about Mary’s age (which was available in the age.y column above). dfs %&gt;% reduce(full_join, by = &quot;name&quot;, suffix = c(&quot;&quot;, &quot;.y&quot;)) %&gt;% select(-ends_with(&quot;.y&quot;)) ## # A tibble: 2 × 4 ## name age sex treatment ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John 30 M &lt;NA&gt; ## 2 Mary NA F A 2.3 Using powerjoin::power_full_join Solve the problem using powerjoin. Let’s consider the dfs list with one more row. The problems we have when using dplyr::full_join and how powerjoin::power_full_join can be helpful. dfs &lt;- list( first = tibble(name = &quot;John&quot;, age = 30), second = tibble(name = c(&quot;John&quot;, &quot;Mary&quot;), sex = c(&quot;M&quot;, &quot;F&quot;)), third = tibble(name = &quot;Mary&quot;, treatment = &quot;A&quot;), fourth = tibble(name = &quot;Mary&quot;, age = 45), fifth = tibble(name = &quot;Mary&quot;, sex = &quot;F&quot;) ) dfs %&gt;% reduce(full_join) ## Joining, by = &quot;name&quot; ## Joining, by = &quot;name&quot; ## Joining, by = c(&quot;name&quot;, &quot;age&quot;) ## Joining, by = c(&quot;name&quot;, &quot;sex&quot;) ## # A tibble: 3 × 4 ## name age sex treatment ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John 30 M &lt;NA&gt; ## 2 Mary NA F A ## 3 Mary 45 &lt;NA&gt; &lt;NA&gt; dfs %&gt;% reduce(full_join, by = &quot;name&quot;) ## # A tibble: 2 × 6 ## name age.x sex.x treatment age.y sex.y ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 John 30 M &lt;NA&gt; NA &lt;NA&gt; ## 2 Mary NA F A 45 F The powerjoin package helps us collect all available information. dfs %&gt;% power_full_join(by= &quot;name&quot;, conflict = coalesce_xy) ## # A tibble: 2 × 4 ## name treatment age sex ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 John &lt;NA&gt; 30 M ## 2 Mary A 45 F 2.4 What if we have conflict data sets Now, consider that we have two data sets for Mary that have different values for “age” (the fourth and fifth), with ages equal to 45 and 65, respectively. dfs &lt;- list( first = tibble(name = &quot;John&quot;, age = 30), second = tibble(name = c(&quot;John&quot;, &quot;Mary&quot;), sex = c(&quot;M&quot;, &quot;F&quot;)), third = tibble(name = &quot;Mary&quot;, treatment = &quot;A&quot;), fourth = tibble(name = &quot;Mary&quot;, age = 45), fifth = tibble(name = &quot;Mary&quot;, age = 65) ) Then the argument conflict = coalesce_xy will take the first available value (age = 45), while conflict = coalesce_yx will take the second available value (age = 65). dfs %&gt;% power_full_join(by= &quot;name&quot;, conflict = coalesce_xy) ## # A tibble: 2 × 4 ## name sex treatment age ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 John M &lt;NA&gt; 30 ## 2 Mary F A 45 dfs %&gt;% power_full_join(by= &quot;name&quot;, conflict = coalesce_yx) ## # A tibble: 2 × 4 ## name sex treatment age ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 John M &lt;NA&gt; 30 ## 2 Mary F A 65 2.5 Reference https://github.com/moodymudskipper/powerjoin "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
